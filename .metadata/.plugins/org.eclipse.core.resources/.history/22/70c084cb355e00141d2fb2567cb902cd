/**
 * @file Graph_Structure.h
 *
 * @date 27-10-2014
 * @author Kamil Sorokosz
 * @brief File Graph_Structure.h contains graph data structure
 */

#ifndef _GRAPH_STRUCTURE_H_
#define _GRAPH_STRUCTURE_H_

#include <string>
#include <vector>
#include <list>
#include <set>

using namespace std;

/* Vertex */
class Vertex
{
public:

	/* Vertex constructor */
	Vertex( int vertex_id, string vertex_name )
	{
		this->vertex_name = vertex_name;
		this->vertex_id   = vertex_id;
	}

	/* Get vertex ID */
	int get_id() const
	{
		return this->vertex_id;
	}

	/* Get vertex name */
	string get_name() const { return this->vertex_name; }

	/* Comparison operator */
	bool operator<(const Vertex& vertex) const
	{
		return this->vertex_id < vertex.get_id();
	}

	/* Equal operator */
	bool operator==(const Vertex& vertex) const
	{
		return this->vertex_id == vertex.get_id();
	}

private:

	/* Vertex id */
	int vertex_id;

	/* Vertex name */
	string vertex_name;

};

/* Edge definition */
class Edge
{
public:

	/* Edge constructor */
	Edge( const Vertex& begin, const Vertex& end, int weight ) : fvertex( begin.get_id(), begin.get_name() ),
	                                                             svertex( end.get_id(), end.get_name() )
	{
		this->weight  = weight;
	}

	/* Comparison operator < */
	bool operator<(const Edge& edge) const
	{
		return this->weight < edge.weight ? true : false;
	}

	/* Equal operator */
	bool operator==(const Edge& edge) const
	{
		return this->fvertex == edge.fvertex &&
			   this->svertex == edge.svertex;
	}

	/* Get beginning vertex */
	const Vertex& get_begin() const
	{
		return fvertex;
	}

	/* Get ending vertex */
	const Vertex& get_end() const
	{
		return svertex;
	}

	/* Get weight */
	int get_weight() const
	{
		return weight;
	}

	/* Get reverted edge */
	Edge get_reverted_edge() const
	{
		/* Declare */
		Edge reverted = Edge( this->svertex, this->fvertex, this->weight );

		/* Return reverted edge */
		return reverted;
	}

private:
	/* First vertex */
	Vertex fvertex;

	/* Second vertex */
	Vertex svertex;

	/* Weight */
	int weight;
};

/* Graph class */
class Graph
{
public:

	/* Graph constructor */
	Graph( const vector< Edge >& edges, bool undirected = true );

	/* Get edges from graph */
	const vector< Edge >& graph_get_sorted_edges() const;

	/* Get vertices from graph */
	const set< Vertex >& graph_get_sorted_vertices() const;

protected:

	/* Read graph from edges into adjacent list */
	void graph_create_neighbors_matrix( int vertices_number, const vector< Edge >& edges );

	/* Read graph from edges into adjacent matrix */
	void graph_create_neighbors_list( int vertices_number, const vector< Edge >& edges );

private:

	/* Directed or undirected graph */
	bool undirected;

	/* Neighbors matrix */
	vector< vector< int > > neighbors_matrix;

	/* Neighbors list */
	vector< list< Edge > > neighbors_list;

	/* Sorted Edges */
	vector< Edge > edges;

	/* Sorted Vertices */
	set< Vertex > vertices;
};

Graph::Graph( const vector< Edge >& edges, bool undirected )
{
	/* Set undirected flag */
	this->undirected = undirected;

	/* For each edge */
	for ( vector< Edge >::const_iterator edge = edges.begin(); edge != edges.end(); edge++ )
	{
		/* Insert vertices */
		this->vertices.insert( edge->get_begin() );
		this->vertices.insert( edge->get_end() );

		/* Insert edge */
		this->edges.insert( (*edge ) );
	}

	/* Create neighbors list */
	graph_create_neighbors_list( this->vertices.size(), edges );

	/* Create neighbors matrix */
	graph_create_neighbors_matrix( this->vertices.size(), edges );
}

/* Get vertices from edges */
const set< Vertex >& Graph::graph_get_sorted_vertices() const
{
	return this->vertices;
}

/* Get edges from neighbor list */
const set< Edge >& Graph::graph_get_sorted_edges() const
{
	return this->edges;
}

/* Read graph from file - neighbor list */
void Graph::graph_create_neighbors_list( int vertices_number, const vector< Edge >& edges )
{
	/* Allocate graph */
	this->neighbors_list.resize( vertices_number );

	/* For each edge */
	for ( vector< Edge >::const_iterator edge = edges.begin(); edge != edges.end(); edge++ )
	{
		int beginning = edge->get_begin().get_id();
		int ending    = edge->get_end().get_id();

		/* Directed and undirected graph */
		this->neighbors_list[ beginning ].push_back( (*edge) );

		/* Undirected graph */
		if ( this->undirected )
		{
			/* Create reverted edge */
			this->neighbors_list[ ending ].push_back( edge->get_reverted_edge() );
		}
	}
}

/* Read graph from file - neighbor matrix */
void Graph::graph_create_neighbors_matrix( int vertices_number, const vector< Edge >& edges )
{
	/* Allocate graph matrix */
	this->neighbors_matrix.resize(vertices_number);

	/* Initialize rows */
	for ( int vertex_id = 0; vertex_id < vertices_number; vertex_id++ )
		this->neighbors_matrix[vertex_id].resize(vertices_number, 0);

	/* For each edge */
	for ( vector< Edge >::const_iterator edge = edges.begin(); edge != edges.end(); edge++ )
	{
		int beginning = edge->get_begin().get_id();
		int ending    = edge->get_end().get_id();

		/* Directed and undirected graph */
		this->neighbors_matrix[ beginning ][ ending ] = 1;

		/* Undirected graph */
		if ( this->undirected )
		{
			this->neighbors_matrix[ ending ][ beginning ] = 1;
		}
	}
}


#endif /* _GRAPH_STRUCTURE_H_ */
