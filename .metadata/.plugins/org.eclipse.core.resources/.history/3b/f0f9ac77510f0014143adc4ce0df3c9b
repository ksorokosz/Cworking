#include "Cworking_Signal_Processing_Infrastructure_Layer.h"

void Cworking_Infrastructure_Layer::cworking_allocate_random_data( Cworking_Input_Data& cworking_input_data )
{
	/* Symbols number */
		cworking_input_data.cworking_radio_frame.cols = CWORKING_BLOCK_SIZE;

		/* Sub-carriers number */
		cworking_input_data.cworking_radio_frame.rows = CWORKING_SYMBOLS_NUMBER;

		/* Create frame */
		cworking_input_data.cworking_radio_frame.matrix = new Cworking_Complex_Scalar*[ cworking_input_data.cworking_radio_frame.rows ];

		/* Initialize each block and symbol */
		for ( int cworking_symbol = 0; cworking_symbol < cworking_input_data.cworking_radio_frame.rows; cworking_symbol++ )
		{
				/* Allocate memory */
				cworking_input_data.cworking_radio_frame.matrix[ cworking_symbol ] = new Cworking_Complex_Scalar[ cworking_input_data.cworking_radio_frame.cols ];

				/* Initialize memory */
				for ( int cworking_subcarrier = 0; cworking_subcarrier < cworking_input_data.cworking_radio_frame.cols; cworking_subcarrier++ )
				{
					/* Initialize to 0 */
					cworking_input_data.cworking_radio_frame.matrix[ cworking_symbol ][ cworking_subcarrier ] = MUGED_Complex( 0, 0 );
				}
		}
}

void Cworking_Infrastructure_Layer::cworking_create_random_data( Cworking_Input_Data& cworking_input_data )
{
	/* For each block and half symbols */
	for ( int cworking_symbol = 0; cworking_symbol < cworking_input_data.cworking_radio_frame.rows / 2; cworking_symbol++ )
	{
		for ( int cworking_subcarrier = 0; cworking_subcarrier < cworking_input_data.cworking_radio_frame.cols; cworking_subcarrier++ )
		{
			/* Angle */
			double cworking_angle = 135;

			/*
			 * QPSK symbols
			 * Each could be written as 1 * exp(-j*angle), where angle equals: 45, 135, 225, 315
			 */
			Cworking_Complex_Scalar random_qpsk_value = MUGED_Complex( 1, cworking_angle * 180 / CWORKING_PI , false );

			/* Store random value */
			cworking_input_data.cworking_radio_frame.matrix[ cworking_symbol ][ cworking_subcarrier ] = random_qpsk_value;
		}
	}
}

void Cworking_Infrastructure_Layer::cworking_delete_random_data( Cworking_Input_Data& cworking_input_data )
{
	/* Clear memory */
	for ( int cworking_symbol = 0; cworking_symbol < cworking_input_data.cworking_radio_frame.rows; cworking_symbol++ )
	{
		delete [] cworking_input_data.cworking_radio_frame.matrix[ cworking_symbol ];
	}
	delete [] cworking_input_data.cworking_radio_frame;
}

