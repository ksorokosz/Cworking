/**
 * @file Algorithms_Graphs.h
 *
 * @date 27-10-2014
 * @author Kamil Sorokosz
 * @brief File Algorithms_Graphs.h contains graphs algorithms
 */

#ifndef _ALGORITHMS_GRAPHS_H_
#define _ALGORITHMS_GRAPHS_H_

/* Graph representation */
#include "Graph_Structure.h"

#include <algorithm>
#include <cstdlib>
#include <iostream>

using namespace std;

/* Union find */
class Union_Find
{
public:

	/* Create Union Find structure */
	Union_Find( int objects_number )
	{
		/* Create union find object list */
		for ( int object = 0; object < objects_number; object++ )
		{
			/* Store union find object */
			this->objects.push_back( object );

			/* Initialize component size */
			this->components_sizes.push_back( 1 );
		}
	}

	/* Compare objects of two object */
	bool compare( int fobject, int sobject )
	{
		return get_component_id( fobject ) == get_component_id( sobject );
	}

	/* Merge objects of two object */
	void merge( int fobject, int sobject )
	{
		/* Get component id */
		int fcomponent_id = get_component_id( fobject );
		int scomponent_id = get_component_id( sobject );

		/* Compare sizes */
		if ( this->components_sizes[ fcomponent_id ] > this->components_sizes[ scomponent_id ] )
		{
			/* Update size */
			this->components_sizes[ fcomponent_id ] += this->components_sizes[ scomponent_id ];
			this->components_sizes[ scomponent_id ]  = 0;

			/* Update component id */
			update_component_id( sobject, fcomponent_id);
		}
		else
		{
			/* Update size */
			this->components_sizes[ scomponent_id ] += this->components_sizes[ scomponent_id ];
			this->components_sizes[ fcomponent_id ]  = 0;

			/* Update component id */
			update_component_id( fobject, scomponent_id);
		}
	}

protected:

	/* Get component id */
	int get_component_id( int object )
	{
		return this->objects[ object ];
	}

	/* Update component id */
	void update_component_id( int object, int component_id )
	{
		this->objects[ object ] = component_id;
	}

private:

	/* Components objects */
	vector< int > objects;

	/* Components sizes */
	vector< int > components_sizes;
};

/* Minimum spanning tree */
inline Graph algorithm_minimum_spanning_tree_kruskal( int vertex_number, const Graph& graph )
{
	/* Get graph edges */
	vector< Edge > sorted_edges = graph.get_edges();

	/* Get graph vertices */
	vector< Vertex > vertices   = graph.get_vertices();

	/* Sort edges */
	sort( sorted_edges.begin(), sorted_edges.end() );

	for ( vector< Edge >::const_iterator edge = sorted_edges.begin(); edge != sorted_edges.end(); edge++ )
	{
		cout << edge->get_begin().get_name() << " " << edge->get_end().get_name() << " " << edge->get_weight() << endl;
	}

	/* Create union find structure */
	Union_Find union_find = Union_Find( vertices.size() );

	/* Minimum Spanning Tree */
	vector< Edge > minimum_spanning_tree_edges;

	/* For each edge in ascending order */
	for ( vector< Edge >::const_iterator edge = sorted_edges.begin();
		  edge != sorted_edges.end(); edge++ )
	{
		/* Get vertices */
		int fvertex = edge->get_begin().get_id();
		int svertex = edge->get_end().get_id();

		/* If inside different components - omit cycles */
		if ( ! union_find.compare( fvertex, svertex ) )
		{
			/* Add to minimum spanning tree */
			minimum_spanning_tree_edges.push_back( (*edge) );

			/* Merge components */
			union_find.merge( fvertex, svertex );
		}
	}

	/* Create graph from minimum spanning tree */
	Graph minimum_spanning_tree = Graph( minimum_spanning_tree_edges );

	/* Return MST */
	return minimum_spanning_tree;
}

#endif /* _ALGORITHMS_GRAPHS_H_ */
