/**
 * @file Algorithms_TextProcessing.h
 *
 * @date 25-10-2014
 * @author Kamil Sorokosz
 * @brief File Algorithms_TextProcessing.h contains text processing algorithms
 */

#ifndef _ALGORITHMS_TEXTPROCESSING_H_
#define _ALGORITHMS_TEXTPROCESSING_H_

#include <vector>
#include <string>
#include <sstream>
#include <cstdlib>
using namespace std;

/* Return maximum value */
inline int algorithm_maximum( int fvalue, int lvalue )
{
	return fvalue > lvalue ? fvalue : lvalue;
}

/* Prefix - Suffix array: linear complexity */
inline void algorithm_prefix_suffix_array( const string& text, vector<int>& array )
{
	/* Initialize array */
	array.clear();
	array.push_back(-1);
	for ( unsigned int j = 0; j < text.length(); j++ )
	{
		array.push_back(0);
	}

	/* Initialize prefix-suffix length */
	int t = -1;

	/* For substring (common beginning) - linear complexity */
	for ( unsigned int j = 1; j < text.length(); j++ )
	{
		while ( t >= 0 && text[ t ] != text[ j - 1 ] )
		{
			t = array[t];
		}
		t++;

		/* Store prefix-suffix length */
		array[ j ] = t;
	}
}

/* Strong prefix-suffix array */
inline void algorithm_strong_prefix_suffix_array( const string& text, vector<int>& array )
{
	/* Initialize array */
	array.clear();
	array.push_back(-1);
	for ( unsigned int j = 0; j < text.length(); j++ )
	{
		array.push_back(0);
	}

	/* Initialize prefix-suffix length */
	int t = -1;

	/* For substring (common beginning) - linear complexity */
	for ( unsigned int j = 1; j < text.length(); j++ )
	{
		while ( t >= 0 && text[ t ] != text[ j - 1 ] )
		{
			t = array[t];
		}
		t++;

		/* Strong prefix-suffix processing part */
		if ( j == text.length() || text[ t ] != text[ j ] )
		{
			array[ j ] = t;
		}
		else
		{
			array[ j ] = array[ t ];
		}
	}
}

/* Max Suffix algorithm */
inline int algorithm_max_suffix( const string& text )
{
	/* Declare max suffix index */
 	int max_suffix = 0;
	int i = 1;
	int p = 1;
	int r = 0;

	while ( i <= (int)text.length() )
	{
		r = ( i - max_suffix ) % p;
		if ( text[ i ] == text[ max_suffix + r ] )
			i++;
		else if ( text[ i ] < text[ max_suffix + r ] )
		{
			i++;
			p = i - max_suffix;
		}
		else
		{
			max_suffix = i - r;
			i = max_suffix + 1;
			p = 1;
		}
	}

	return max_suffix;
}

/* Morris-Prat algorithm */
inline bool algorithm_morris_prat( const string& text, const string& pattern )
{
	/* Declare variables */
	vector<int> array;

	int i, j;
	i = j = 0;

	if ( text.length() <= pattern.length() )
	{
		exit( EXIT_FAILURE );
	}

	/* Calculate prefix-suffix array */
	algorithm_prefix_suffix_array( pattern, array );

	/* For each i */
	while ( i != ( (int)text.length() - (int)pattern.length() ) )
	{
		/* For each pattern sign */
		while ( j < (int)pattern.length() && pattern[j] == text[i+j] )
			j++;

		/* If pattern was found */
		if ( j == (int)pattern.length() )
		{
			return true;
		}

		i = i + j - array[j];
		j = algorithm_maximum( 0, array[j] );
	}

	return false;
}

/* Knuth-Morris-Prat algorithm */
inline bool algorithm_knuth_morris_prat( const string& text, const string& pattern )
{
	/* Declare variables */
	vector<int> array;

	int i, j;
	i = j = 0;

	if ( text.length() <= pattern.length() )
	{
		exit( EXIT_FAILURE );
	}

	/* Calculate prefix-suffix array */
	algorithm_strong_prefix_suffix_array( pattern, array );

	/* For each i */
	while ( i != ( (int)text.length() - (int)pattern.length() ) )
	{
		/* For each pattern sign */
		while ( j < (int)pattern.length() && pattern[j] == text[i+j] )
			j++;

		/* If pattern was found */
		if ( j == (int)pattern.length() )
		{
			return true;
		}

		i = i + j - array[j];
		j = algorithm_maximum( 0, array[j] );
	}

	return false;
}

/* Search for maximum palindrome */
inline string algorithm_manachera_palindrome( const string& text )
{
	/* Declare variables */
	vector< vector<int> > R;
	stringstream buffer;
	string processed_text;

	int palindrom_radius   = 0;
	int palindrom_position = 0;
	int max_length         = 0;

	/* Add guardians */
	buffer << "@" << text << "#";

	/* Store in string */
	processed_text = buffer.str();

	// even or odd (ABBA or ABCBA)
	for ( int palindrom_type = 0; palindrom_type <= 1; palindrom_type++ )
	{
		palindrom_radius = 0;
		for ( int counter = 1 ; counter < processed_text.length(); )
		{
			while ( sequence[ counter + radius + type ] ==
					sequence[ counter - radius ] )
			{
				radius++; /* Search maximum palindrom on counter position */
			}

			int pal_length = type == 0 ? 2 * radius - 1 : 2 * radius;
	if ( pal_length > max_length )
	{
	max_length = pal_length;
	position = counter - radius + 1;
	}
	/* Search other palindroms */
	int k = 1;
	while(k <= radius && R[type][counter - k] != R[type][counter] - k)
	{
	R[type][counter + k] = R[type][counter-k] < (R[type][counter]-k) ?
	R[type][counter-k] : R[type][counter] - k;
	k++;
	}
	radius -= k;
	radius = radius > 0 ? radius : 0;
	counter += k;
	}
	}
	if ( position >= 1 )
	printf("%d\n", 1 );
	else
	printf("%d\n", 0);
	printf("%d %d\n", position, max_length);
	free(R[0]);
	free(R[1]);
	free(R);
	free( sequence );
	}
	return 0;
}


#endif /* _ALGORITHMS_TEXTPROCESSING_H_ */
