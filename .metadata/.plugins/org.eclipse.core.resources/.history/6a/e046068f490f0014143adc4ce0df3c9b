#include "Cworking_Signal_Processing_Infrastructure_Layer.h"

void Cworking_Infrastructure_Layer::cworking_parse_file(
		const char* cworking_filename, Cworking_Input_Data& cworking_input_data)
{

	/* Symbols number */
	cworking_input_data.cworking_matrix.cols = CWORKING_SYMBOLS_NUMBER;

	/* Sub-carriers number */
	cworking_input_data.cworking_matrix.rows = CWORKING_BLOCK_SIZE;

	/* Create frame */
	cworking_input_data.cworking_matrix.matrix =
			new Cworking_Complex_Scalar[ CWORKING_BLOCK_SIZE ][ CWORKING_SYMBOLS_NUMBER ];

	/* For each block and each symbol */
	for ( int cworking_block = 0; cworking_block < CWORKING_BLOCK_SIZE; cworking_block++ )
		for ( int cworking_symbol = 0; cworking_symbol < CWORKING_SYMBOLS_NUMBER; cworking_symbol++ )
		{
			/*
			 * QPSK symbols
			 * Each could be written as 1 * exp(-j*angle), where angle equals: 45, 135, 225, 315
			 */
			Cworking_Complex_Scalar random_qpsk_value = MUGED_Complex( 1, 45 * 180 / PI , false );

			/* Store random value */
			cworking_input_data.cworking_matrix.matrix[ cworking_block ][ cworking_symbol ] = random_qpsk_value;
		}
}
